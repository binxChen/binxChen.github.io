[{"title":"js解 code-543 二叉树的直径","url":"/2020/03/10/code-543/","content":"\n---\n<font size=2>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</font>\n\n```\n          1\n         / \\\n        2   3\n       / \\     \n      4   5  \n```\n<font size=2>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。\n\n注意：两结点之间的路径长度是以它们之间边的数目表示。</font>\n\n---\n\n大神写的题解\n```\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar diameterOfBinaryTree = function(root) {\n    // 默认为1是因为默认了根节点自身的路径长度\n    let ans = 1;\n\n    function depth(rootNode) {\n        if (!rootNode) {\n            // 如果不存在根节点，则深度为0\n            return 0;\n        }\n        // 递归，获取左子树的深度\n        let L = depth(rootNode.left);\n        // 递归，获取右子树的深度\n        let R = depth(rootNode.right);\n\n        /* 关键点1\n        L+R+1的公式是如何而来？\n        等同于：左子树深度(节点个数) + 右子树深度（节点个数） + 1个根节点\n        便是这株二叉树从最左侧叶子节点到最右侧叶子节点的最长路径\n        类似于平衡二叉树的最小值节点到最大值节点的最长路径\n        之所以+1是因为需要经过根节点\n         */\n        // 获取该树的最长路径和现有最长路径中最大的那个\n        ans = Math.max(ans, L + R + 1);\n        /* 关键点2\n        已知根节点的左右子树的深度，\n        则，左右子树深度的最大值 + 1，\n        便是以根节点为数的最大深度*/\n        return Math.max(L, R) + 1;\n    }\n\n    depth(root);\n\n    // 由于depth函数中已经默认加上数节点的自身根节点路径了，故此处需减1\n    return ans - 1;\n}; \n```\n\n自己的理解：\n一开始以为是找出最高的父节点左边最高的高度与右边的最高的高度，后来发现有可能是中间节点的。\n另外中间一开始自己写的时候忘了考虑边界值，导致报错，一直在纠结。\n\n总结是：还是要多写算法，二叉树的是个较大的弱项。"},{"title":"typescript---项目中使用的ts总结与学习","url":"/2020/03/10/typescript/","content":"\n##  ts---项目中使用的ts总结与学习\n\n<font size=3>前言：  公司的项目近一年逐渐的在转型成ts，（当初入职就是听说这里技术栈使用非常的新，并且在不停的进步中，也是很感谢公司给了这么好的机会）</font>\n\ntypescript对比js的优势和好处，很多人都说了，请自行百度。\n我会从代码入手，总结一些，自己或者是别人写的ts，并给出对应的适用场景。\n\n1.变量，变量声明，类型，返回模版，类型断言\n\n两个例子\n![](..\\img\\ts1.png)\n\n![](..\\img\\ts2.png)\n\n<font size=3>优势的地方在于，第一，定义了入参和返回，那么在调用的时候就不用再去翻接口，是否遗漏了，或者是关键参数的字段名是啥等问题。</font>\n\n举个例子： 你对照接口文档写上了以上的类型说明，过了一天（或者很多天），发现还有一处调用同一个接口的地方，以前：翻出文档，重新对照字段一个个的配置，然后复制粘贴字段，忙活半天，现在就不用了，你从api目录下按照对应模块快速搜索到这个接口，字段以及功能一目了然，包括了最底下的type的枚举类型也清晰的看到（当然这里应该再引用一个枚举类型定义的）\n\n第二; 不用再担心字段类型写错，字段名称写错，传参数量不对等，统统都有提示。\n\n第三，返回时参数能一一对应，不用担心我在返回参数中出现underfined，导致报错\n\n\n另外以上做法还有一个比较实用的用途是，前后端并行开发接口\n\n  以前：项目确定，后端开始开发，前端只能自己撸Mock,自己对照页面想字段名，自己模拟数据，效率其实很低下，尤其是对于管理台系统来说，很多页面就是一个tableData就了事，页面很快做完就得等待后端一个一个模块完成之后再重头对着文档一个个模块开始对接字段，效率低下。\n\n  现在：项目确定，后端花个一天时间写出文档，前端这个时候就整体搭建项目，等到文档到手，按照ts规范一个个，写好字段之后，就可以开始写交互逻辑，等到后端模块写完部署上服务器，你只要打开页面，整个系统就基本运行起来了（如果双方都不出问题的话）。对接时间可以大大的缩小，前后端并行开发，缩短开发时间！\n\n枚举类型\n![](..\\img\\ts3.png)\n\n使用场景： 用于向后端发送请求时发送对应的枚举值，而不用去翻文档\n\n学习：\n抽象类/抽象方法 abstract\n\n```\nabstract class Animal {\n    abstract eat(); // 抽象方法\n    // 普通方法\n    sleep(){\n      console.log('sleep')\n    }\n}\n\nlet a = new Animal(); // 报错，抽象类不能被实例化\n\nclass Cat extends Animal {\n    eat(){ \n        // 父类的eat方法必须被实现\n      console.log('eat')\n    }\n}\n```\n\n泛型\n泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。","tags":["typescript"]},{"title":"code-121. 买卖股票的最佳时机","url":"/2020/03/10/code-121/","content":"\n-----------\n><font face=\"微软雅黑\" size=2>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n>\n>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。\n>\n>注意你不能在买入股票前卖出股票。</font>\n><font face=\"微软雅黑\" size=2>\n>例如[7,6,1,6,4,2,5]     输出5</font>\n\n<font face=\"微软雅黑\" size=2>\n初步想法（即遍历,即暴力解法）：\n循环，找出两个元素之间道差价正数最大值</font>\n\n```\n/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    let a = [],b=[];\n    for(let j=0;j<prices.length;j++){\n        let i = j;\n        while (i<prices.length){\n            a.push(prices[i] - prices[j]);\n            i++;\n        }\n    }\n    let max = Math.max.apply(0, a)\n    return max > 0 ? max : 0\n};\n```\n\n<font face=\"微软雅黑\" size=2>然后，被leetcode爆了内存，不给过，mdzz\n\n难受，哈哈哈\n\n然后又修改了一下</font>\n\n```\nvar maxProfit = function(prices) {\n    let max = 0\n    for(let j=0;j<prices.length;j++){\n        let i = j;\n        while (i<prices.length){\n            max = Math.max(max, prices[i] - prices[j])\n            i++;\n        }\n    }\n    return max\n};\n```\n\n<font face=\"微软雅黑\" size=2>动态规划版本，等下次吧，我好好研究一下</font>"},{"title":"微前端探究--在项目中实际的落地","url":"/2020/03/09/weiqianduan/","content":"#### 微前端探究--在项目中实际的落地\n##### 物联网中台项目的回顾\n\n","tags":["前端  架构"]}]